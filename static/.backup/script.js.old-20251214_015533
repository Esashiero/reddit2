Here's the final valid Python code with all the changes applied:

```python
// GLOBAL STATE
let activeSubreddits = [];

document.addEventListener('DOMContentLoaded', async () => {
    await fetchAndRenderSubreddits();
    addNewGroup();
    fetchSavedQueries();
    fetchHistory();
    toggleTimeFilter();
    updateExplainer();

    document.getElementById('deep_scan').addEventListener('change', function() {
        const manualInput = document.getElementById('scan_limit');
        manualInput.disabled = this.checked;
        manualInput.style.opacity = this.checked ? "0.5" : "1";
        updateExplainer();
    });

    document.getElementById('raw-query-input').addEventListener('input', syncRawToBuilder);
});

// --- NEW: RAW QUERY SYNC ---

// 1. Raw Text -> Visual Builder
function syncRawToBuilder() {
    const raw = document.getElementById('raw-query-input').value;
    const container = document.getElementById('builder-container');
    container.innerHTML = ''; // Clear visual builder

    // Parse logic: Match (groups)
    // Supports (A OR B) AND (C OR D) or just (A OR B) (C OR D)
    const parenRegex = /\(([^)]+)\)/g;
    let match;
    let found = false;

    while ((match = parenRegex.exec(raw)) !== null) {
        found = true;
        const groupTerms = match[1].split(/ OR |\|/i).map(s => s.trim().replace(/"/g, '')).filter(s => s);
        if (groupTerms.length > 0) {
            const groupDiv = addNewGroup(false); // Add group without triggering sync back
            const termContainer = groupDiv.querySelector('.terms-container');
            termContainer.innerHTML = ''; // Clear default input
            groupTerms.forEach(term => addTermToContainer(termContainer, term, false));
        }
    }

    // If empty/invalid, reset to one empty group
    if (!found && raw.trim() === '') {
        addNewGroup(false);
    }

    updatePreviewOnly(); // Update the green preview box
}

// 2. Visual Builder -> Raw Text
function syncBuilderToRaw() {
    const groups = document.querySelectorAll('.query-group');
    let blocks = [];

    groups.forEach(group => {
        const inputs = group.querySelectorAll('input');
        let terms = [];
        inputs.forEach(inp => {
            const val = inp.value.trim();
            if (val) terms.push(val);
        });

        if (terms.length > 0) {
            // Join terms with OR
            blocks.push(`(${terms.join(" OR ")})`);
        }
    });

    // Join groups with AND
    const rawString = blocks.join(" AND ");
    document.getElementById('raw-query-input').value = rawString;
    updatePreviewOnly();
}

// 3. AI Generator
async function generateAIQuery() {
    const desc = document.getElementById('ai-gen-input').value;
    const btn = document.querySelector('#ai-gen-input + button');

    if(!desc) return alert("Please describe what you want.");

    btn.disabled = true;
    btn.innerHTML = "Generating...";

    try {
        const res = await fetch('/api/generate_query', {
            method: 'POST',
            headers: {'Content-Type': 'application/json'},
            body: JSON.stringify({
                description: desc,
                provider: document.getElementById('provider').value
            })
        });
        const data = await res.json();

        if(data.query) {
            document.getElementById('raw-query-input').value = data.query;
            syncRawToBuilder(); // Trigger UI update
        } else {
            alert("AI Error: " + (data.error || "Unknown"));
        }
    } catch(e) {
        alert("Network Error");
    }

    btn.disabled = false;
    btn.innerHTML = "Generate Logic";
}

// --- MODIFIED BUILDER FUNCTIONS (To support sync) ---

function addNewGroup(triggerSync = true) {
    const container = document.getElementById('builder-container');
    const groupDiv = document.createElement('div');
    groupDiv.className = 'query-group';
    groupDiv.innerHTML = `
        <div class="group-header">
            <span>MUST MATCH (AND)</span>
            <button class="btn-icon" onclick="removeGroup(this)" title="Remove Group">&times;</button>
        </div>
        <div class="terms-container"></div>
        <button class="btn-add-term" onclick="addTerm(this)">+ Add "OR" Term</button>
    `;
    container.appendChild(groupDiv);

    // Add default empty input
    if (triggerSync) {
        addTermToContainer(groupDiv.querySelector('.terms-container'), "", true);
    }
    return groupDiv;
}

function addTerm(btn) {
    addTermToContainer(btn.previousElementSibling, "", true);
}

function addTermToContainer(container, value="", triggerSync=true) {
    const row = document.createElement('div');
    row.className = 'term-row';
    row.innerHTML = `
        <input type="text" placeholder="keyword..." value="${value}" oninput="syncBuilderToRaw()">
        <button class="btn-icon" onclick="removeTerm(this)">&times;</button>
    `;
    container.appendChild(row);
    if(!value && triggerSync) row.querySelector('input').focus();

    if(triggerSync) syncBuilderToRaw();
}

function removeTerm(btn) {
    btn.parentElement.remove();
    syncBuilderToRaw();
}

function removeGroup(btn) {
    btn.closest('.query-group').remove();
    syncBuilderToRaw();
}

// --- DATA EXTRACTION (For Search) ---
function getBuilderData() {
    // We can now just parse the raw string directly or use the DOM.
    // Let's stick to DOM for consistency with previous logic.
    const groups = document.querySelectorAll('.query-group');
    let logicalGroups = [];
    groups.forEach(group => {
        const inputs = group.querySelectorAll('input');
        let terms = [];
        inputs.forEach(inp => { if (inp.value.trim()) terms.push(inp.value.trim()); });
        if (terms.length > 0) logicalGroups.push(terms);
    });
    return logicalGroups;
}

function updatePreviewOnly() {
    const groups = getBuilderData();
    const previewBox = document.getElementById('combo-preview');
    if (groups.length === 0) { previewBox.innerHTML = "Add terms..."; return; }

    const combinations = cartesian(groups);
    let html = "";
    // Limit preview to 20 lines to prevent UI lag on huge queries
    const displayLimit = 20;
    combinations.slice(0, displayLimit).forEach(combo => {
        const line = Array.isArray(combo) ? combo.join(" + ") : combo;
        html += `<div class="preview-item">üîé ${line}</div>`;
    });
    if (combinations.length > displayLimit) {
        html += `<div class="preview-item" style="color:#888">...and ${combinations.length - displayLimit} more combinations</div>`;
    }
    previewBox.innerHTML = html;
}

// --- HELPER ---
function cartesian(args) {
    if (args.length === 0) return [];
    const r = [], max = args.length-1;
    function helper(arr, i) {
        for (let j=0, l=args[i].length; j<l; j++) {
            const a = arr.slice(0); a.push(args[i][j]);
            if (i==max) r.push(a); else helper(a, i+1);
        }
    }
    helper([], 0);
    return r;
}

// --- UI HELPERS ---
function toggleTimeFilter() {
    const sortVal = document.getElementById('sort_by').value;
    const timeSelect = document.getElementById('time_filter');
    const timeContainer = document.getElementById('time_filter_container');

    // Time filter applies to Top and Relevance
    if (sortVal === 'top' || sortVal === 'relevance') {
        timeSelect.disabled = false;
        timeContainer.style.opacity = "1";
    } else {
        timeSelect.disabled = true;
        timeContainer.style.opacity = "0.5";
    }
}

// --- HISTORY / BLACKLIST UI ---

function toggleHistoryPanel() {
    const panel = document.getElementById('side-panel');
    const overlay = document.getElementById('panel-overlay');
    panel.classList.toggle('open');
    overlay.classList.toggle('show');
}

async function fetchHistory() {
    const container = document.getElementById('history-list');
    container.innerHTML = '<p style="color:#666; text-align:center;">Loading...</p>';

    try {
        const res = await fetch('/api/blacklist');
        const data = await res.json();

        // Convert object to array and sort by new
        const items = Object.values(data).reverse();

        if (items.length === 0) {
            container.innerHTML = '<p style="color:#666; text-align:center;">No history found.</p>';
            return;
        }

        container.innerHTML = '';
        items.forEach(item => {
            const div = document.createElement('div');
            div.className = 'history-card';

            // Truncate criteria for display
            let criteriaShort = item.criteria || "None";
            if (criteriaShort.length > 50) criteriaShort = criteriaShort.substring(0, 50) + "...";

            div.innerHTML = `
                <h4><a href="${item.url}" target="_blank">${item.title}</a></h4>
                <span class="meta-tag">üîé Query: ${item.keywords}</span>
                <span class="meta-tag">ü§ñ Criteria: ${criteriaShort}</span>
                <div style="margin-top:5px; font-size:0.8em; color:#666;">
                    ID: ${item.id}
                </div>
            `;
            container.appendChild(div);
        });

    } catch (e) {
        container.innerHTML = '<p style="color:red; text-align:center;">Error loading history.</p>';
    }
}

async function clearHistory() {
    if(!confirm("Clear all history? Blacklisted posts will reappear in searches.")) return;
    await fetch('/api/blacklist/clear', { method: 'POST' });
    fetchHistory();
}

// --- SUBREDDIT MANAGER ---

async function fetchAndRenderSubreddits() {
    try {
        const res = await fetch('/api/subreddits');
        const data = await res.json();
        activeSubreddits = data; // Array of strings
        renderSubreddits();
    } catch (e) {
        console.error("Failed to load subreddits", e);
    }
}

async function syncSubreddits() {
    // Save current list to backend
    await fetch('/api/subreddits', {
        method: 'POST',
        headers: {'Content-Type': 'application/json'},
        body: JSON.stringify(activeSubreddits)
    });
}

function renderSubreddits() {
    const container = document.getElementById('sub-list-container');
    container.innerHTML = '';
    activeSubreddits.forEach(sub => {
        const tag = document.createElement('span');
        tag.className = 'sub-tag';
        tag.innerHTML = `r/${sub} <span class="remove-sub" onclick="removeSub('${sub}')">&times;</span>`;
        container.appendChild(tag);
    });
    updateExplainer();
}

async function addSubreddit() {
    const input = document.getElementById('new-sub-input');
    let val = input.value.trim().replace(/^r\//, ''); // remove "r/" prefix
    if (val && !activeSubreddits.includes(val)) {
        activeSubreddits.push(val);
        renderSubreddits();
        input.value = '';
        await syncSubreddits(); // Save to file
    }
}

function handleSubInputKey(event) {
    if (event.key === 'Enter') {
        addSubreddit();
    }
}

async function removeSub(sub) {
    activeSubreddits = activeSubreddits.filter(s => s !== sub);
    renderSubreddits();
    await syncSubreddits(); // Save to file
}

// --- MODE SWITCHING ---
function switchMode(mode) {
    document.getElementById('mode-curator').style.display = mode === 'curator' ? 'block' : 'none';
    document.getElementById('mode-discovery').style.display = mode === 'discovery' ? 'block' : 'none';
    document.getElementById('btn-mode-curator').className = mode === 'curator' ? 'tab-btn active' : 'tab-btn';
    document.getElementById('btn-mode-discovery').className = mode === 'discovery' ? 'tab-btn active' : 'tab-btn';
    document.getElementById('results').innerHTML = '';
    document.getElementById('discovery-results').innerHTML = '';
}

// --- SETTINGS EXPLAINER ---
function updateExplainer() {
    const box = document.getElementById('logic-explainer');
    if (!box) return;

    const target = document.getElementById('target_posts').value;
    const isDeep = document.getElementById('deep_scan').checked;
    const limit = document.getElementById('scan_limit').value;
    const subs = activeSubreddits.length;
    const chunk = document.getElementById('ai_chunk').value;

    let text = "";

    // New Explanation for Turbo Mode
    if (isDeep) {
        text = `Script will scan the <strong>combined stream of ${subs} subreddits</strong> (Server-Side). It stops as soon as it finds <strong>${target} candidates</strong>.`;
    } else {
        text = `Script will scan the <strong>newest ${limit} posts</strong> across all ${subs} subreddits simultaneously.`;
    }

    text += `<br><br>Then, the LLM will analyze these <strong>${target} candidates</strong> in groups of <strong>${chunk}</strong>.`;
    text += `<br><em>(Note: Posts previously found in History are skipped automatically).</em>`;

    box.innerHTML = text;
}

// --- SCAN & SAVE ---

async function saveCurrentQuery() {
    const name = document.getElementById('save-name').value.trim();
    if (!name) return alert("Please enter a name.");

    const payload = {
        groups: getBuilderData(),
        criteria: document.getElementById('criteria').value,
        target_posts: document.getElementById('target_posts').value,
        deep_scan: document.getElementById('deep_scan').checked,
        ai_chunk: document.getElementById('ai_chunk').value,
        scan_limit: document.getElementById('scan_limit').value,
        provider: document.getElementById('provider').value,
        subreddits: activeSubreddits,
        // SAVE NEW FILTERS
        sort: document.getElementById('sort_by').value,
        time: document.getElementById('time_filter').value,
        post_type: document.getElementById('post_type').value
    };

    await fetch('/api/queries', {
        method: 'POST',
        headers: {'Content-Type': 'application/json'},
        body: JSON.stringify({ name, payload })
    });

    document.getElementById('save-name').value = "";
    fetchSavedQueries();
    alert("Saved!");
}

async function fetchSavedQueries() {
    const res = await fetch('/api/queries');
    const data = await res.json();
    const select = document.getElementById('saved-list');
    select.innerHTML = '<option value="">-- Select a Preset --</option>';
    for (const [name, payload] of Object.entries(data)) {
        const opt = document.createElement('option');
        opt.value = name;
        opt.textContent = name;
        opt.dataset.payload = JSON.stringify(payload);
        select.appendChild(opt);
    }
}

async function deleteSelectedQuery() {
    const select = document.getElementById('saved-list');
    const name = select.value;
    if(!name) return;
    if(confirm("Delete " + name + "?")) {
        await fetch('/api/queries/' + encodeURIComponent(name), { method: 'DELETE' });
        fetchSavedQueries();
    }
}

function loadSelectedQuery() {
    const select = document.getElementById('saved-list');
    const selectedOpt = select.options[select.selectedIndex];
    if (!selectedOpt.value) return;

    const payload = JSON.parse(selectedOpt.dataset.payload);

    // Clear & Rebuild
    document.getElementById('builder-container').innerHTML = '';
    payload.groups.forEach(groupTerms => {
        const groupDiv = addNewGroup(false);
        const container = groupDiv.querySelector('.terms-container');
        container.innerHTML = '';
        groupTerms.forEach(term => addTermToContainer(container, term, false));
    });

    // Trigger sync to populate Raw Box
    syncBuilderToRaw();

    document.getElementById('criteria').value = payload.criteria || "";
    document.getElementById('target_posts').value = payload.target_posts || 20;
    document.getElementById('ai_chunk').value = payload.ai_chunk || 5;
    document.getElementById('scan_limit').value = payload.scan_limit || 100;
    document.getElementById('provider').value = payload.provider || "mistral";

    // Restore Filters
    if(payload.sort) document.getElementById('sort_by').value = payload.sort;
    if(payload.time) document.getElementById('time_filter').value = payload.time;
    if(payload.post_type) document.getElementById('post_type').value = payload.post_type;
    toggleTimeFilter();

    const deepBox = document.getElementById('deep_scan');
    deepBox.checked = payload.deep_scan || false;

    if (payload.subreddits) { activeSubreddits = payload.subreddits; renderSubreddits(); syncSubreddits(); }
    updateExplainer();
}

// --- EXECUTE ---

function startScan() {
    const logs = document.getElementById('logs');
    const results = document.getElementById('results');
    const btn = document.querySelector('#mode-curator .scan-btn');

    // USE RAW QUERY DIRECTLY FOR CONSISTENCY
    const keywordString = document.getElementById('raw-query-input').value;

    if (!keywordString) return alert("Add keywords first!");

    logs.innerHTML = "üöÄ Initializing...";
    results.innerHTML = "";
    btn.disabled = true;

    const params = new URLSearchParams({
        keywords: keywordString,
        criteria: document.getElementById('criteria').value,
        provider: document.getElementById('provider').value,
        target_posts: document.getElementById('target_posts').value,
        deep_scan: document.getElementById('deep_scan').checked,
        ai_chunk: document.getElementById('ai_chunk').value,
        scan_limit: document.getElementById('scan_limit').value,
        subreddits: activeSubreddits.join(','),
        debug: document.getElementById('debug_mode').checked,
        // NEW FILTERS
        sort: document.getElementById('sort_by').value,
        time: document.getElementById('time_filter').value,
        post_type: document.getElementById('post_type').value
    });

    const eventSource = new EventSource("/stream?" + params.toString());

    eventSource.onmessage = function(e) {
        if (e.data.startsWith("<<<HTML_RESULT>>>")) {
            const htmlContent = e.data.replace("<<<HTML_RESULT>>>", "").replaceAll("||NEWLINE||", "\n");
            results.innerHTML = htmlContent;
            eventSource.close();
            btn.disabled = false;
            logs.innerHTML += "\n‚úÖ Process Complete.";
            logs.scrollTop = logs.scrollHeight;
            fetchHistory();
        } else {
            logs.innerHTML += "\n" + e.data;
            logs.scrollTop = logs.scrollHeight;
        }
    };

    eventSource.onerror = function() {
        eventSource.close();
        btn.disabled = false;
        logs.innerHTML += "\n‚ùå Connection Closed.";
    };
}

function startDiscovery() {
    const logs = document.getElementById('logs');
    const resultsBox = document.getElementById('discovery-results');
    const btn = document.querySelector('#mode-discovery .scan-btn');
    const keywordString = document.getElementById('raw-query-input').value; // USE RAW INPUT

    if (!keywordString) return alert("Add keywords first!");

    logs.innerHTML = "üåç Starting Global Discovery...";
    resultsBox.innerHTML = "";
    btn.disabled = true;

    const params = new URLSearchParams({
        keywords: keywordString,
        limit: document.getElementById('disc_limit').value,
        criteria: document.getElementById('disc_criteria').value,
        provider: document.getElementById('provider').value
    });

    const eventSource = new EventSource("/stream_discovery?" + params.toString());

    eventSource.onmessage = function(e) {
        if (e.data.startsWith("<<<JSON_CARD>>>")) {
            const sub = JSON.parse(e.data.replace("<<<JSON_CARD>>>", ""));
            renderDiscoveryCard(sub);
        } else if (e.data.includes("<<<DONE>>>")) {
            eventSource.close();
            btn.disabled = false;
            logs.innerHTML += "\n‚úÖ Discovery Complete.";
        } else {
            logs.innerHTML += "\n" + e.data;
            logs.scrollTop = logs.scrollHeight;
        }
    };

    eventSource.onerror = function() {
        eventSource.close();
        btn.disabled = false;
        logs.innerHTML += "\n‚ùå Connection Closed.";
    };
}

function renderDiscoveryCard(sub) {
    const box = document.getElementById('discovery-results');
    const div = document.createElement('div');
    div.className = 'sub-card';
    const safeDesc = sub.description ? sub.description.substring(0, 150) + "..." : "No description.";
    div.innerHTML = `
        <h4>r/${sub.name}</h4>
        <span class="stats">Matches found: ${sub.hits}</span>
        <p>${safeDesc}</p>
        <button class="btn-add-sub" onclick="addDiscoverySub('${sub.name}', this)">+ Add to List</button>
    `;
    box.appendChild(div);
}

async function addDiscoverySub(name, btn) {
    if (!activeSubreddits.includes(name)) {
        activeSubreddits.push(name);
        renderSubreddits();
        await syncSubreddits();
        btn.innerHTML = "‚úÖ Added";
        btn.style.background = "#2b7bd6";
        btn.disabled = true;
    } else {
        alert("Already in your list!");
    }
}